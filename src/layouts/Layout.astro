---
import Layout from '../layouts/Layout.astro';
---

<Layout title="F1 Racing Game - Jogue Agora">
  <div class="game-wrapper">
    <div class="game-header">
      <a href="/" class="back-btn">‚Üê Voltar</a>
      <h1>F1 Racing Game</h1>
    </div>
    
    <div class="game-container">
      <canvas id="gameCanvas" width="800" height="600"></canvas>
      
      <div class="ui">
        <div class="score">Pontos: <span id="score">0</span></div>
        <div class="speed">Velocidade: <span id="speed">0</span> km/h</div>
      </div>
      
      <div class="controls">
        <div>üèéÔ∏è Use as setas para controlar</div>
        <div>üéØ Evite as bordas da pista</div>
      </div>
      
      <div class="game-over" id="gameOver">
        <h2>GAME OVER</h2>
        <p>Pontua√ß√£o Final: <span id="finalScore">0</span></p>
        <button class="restart-btn" id="restartBtn">JOGAR NOVAMENTE</button>
      </div>
    </div>
  </div>
</Layout>

<style>
  .game-wrapper {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }

  .game-header {
    display: flex;
    align-items: center;
    gap: 20px;
    margin-bottom: 20px;
  }

  .back-btn {
    color: #ff0000;
    text-decoration: none;
    font-weight: bold;
    padding: 10px 20px;
    border: 2px solid #ff0000;
    border-radius: 25px;
    transition: all 0.3s ease;
  }

  .back-btn:hover {
    background: #ff0000;
    color: white;
  }

  .game-header h1 {
    font-size: 2rem;
    background: linear-gradient(45deg, #ff0000, #ffd700);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .game-container {
    position: relative;
    border: 3px solid #ff0000;
    border-radius: 10px;
    box-shadow: 0 0 50px rgba(255, 0, 0, 0.5);
  }

  canvas {
    display: block;
    background: #2a5d2a;
    border-radius: 7px;
  }

  .ui {
    position: absolute;
    top: 20px;
    left: 20px;
    z-index: 100;
  }

  .score {
    font-size: 24px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    margin-bottom: 10px;
  }

  .speed {
    font-size: 18px;
    color: #ffd700;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
  }

  .controls {
    position: absolute;
    bottom: 20px;
    left: 20px;
    font-size: 14px;
    opacity: 0.8;
  }

  .game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    background: rgba(0, 0, 0, 0.9);
    padding: 40px;
    border-radius: 10px;
    border: 2px solid #ff0000;
    z-index: 200;
    display: none;
  }

  .restart-btn {
    background: linear-gradient(45deg, #ff0000, #ff4500);
    border: none;
    padding: 15px 30px;
    color: white;
    font-size: 16px;
    font-weight: bold;
    border-radius: 25px;
    cursor: pointer;
    margin-top: 20px;
    transition: all 0.3s ease;
  }

  .restart-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 20px rgba(255, 0, 0, 0.3);
  }
</style>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const gameState = {
    player: {
      x: canvas.width / 2,
      y: canvas.height - 100,
      width: 20,
      height: 40,
      speed: 0,
      maxSpeed: 8,
      angle: 0,
      acceleration: 0.3,
      friction: 0.95
    },
    track: {
      centerX: canvas.width / 2,
      width: 200,
      segments: []
    },
    camera: {
      y: 0
    },
    score: 0,
    gameRunning: true,
    keys: {}
  };

  function generateTrack() {
    gameState.track.segments = [];
    let centerX = canvas.width / 2;
    
    for (let i = 0; i < 1000; i++) {
      const variation = Math.sin(i * 0.02) * 150 + Math.cos(i * 0.01) * 100;
      centerX = canvas.width / 2 + variation;
      
      gameState.track.segments.push({
        centerX: centerX,
        width: 200 + Math.sin(i * 0.005) * 50
      });
    }
  }

  function drawTrack() {
    const segmentHeight = 10;
    const visibleSegments = Math.ceil(canvas.height / segmentHeight) + 5;
    const startSegment = Math.floor(gameState.camera.y / segmentHeight);
    
    for (let i = 0; i < visibleSegments; i++) {
      const segmentIndex = startSegment + i;
      if (segmentIndex >= gameState.track.segments.length) continue;
      
      const segment = gameState.track.segments[segmentIndex];
      const y = (segmentIndex * segmentHeight) - gameState.camera.y;
      
      ctx.fillStyle = '#666';
      ctx.fillRect(0, y, canvas.width, segmentHeight);
      
      ctx.fillStyle = '#333';
      const trackLeft = segment.centerX - segment.width / 2;
      const trackRight = segment.centerX + segment.width / 2;
      ctx.fillRect(trackLeft, y, segment.width, segmentHeight);
      
      if (segmentIndex % 10 === 0) {
        ctx.fillStyle = '#fff';
        ctx.fillRect(segment.centerX - 2, y, 4, segmentHeight);
      }
      
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(trackLeft - 5, y, 5, segmentHeight);
      ctx.fillRect(trackRight, y, 5, segmentHeight);
    }
  }

  function drawCar() {
    ctx.save();
    ctx.translate(gameState.player.x, gameState.player.y);
    ctx.rotate(gameState.player.angle);
    
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(-gameState.player.width / 2, -gameState.player.height / 2, 
                gameState.player.width, gameState.player.height);
    
    ctx.fillStyle = '#000';
    ctx.fillRect(-gameState.player.width / 2 + 3, -gameState.player.height / 2 + 5, 4, 8);
    ctx.fillRect(gameState.player.width / 2 - 7, -gameState.player.height / 2 + 5, 4, 8);
    ctx.fillRect(-gameState.player.width / 2 + 3, gameState.player.height / 2 - 13, 4, 8);
    ctx.fillRect(gameState.player.width / 2 - 7, gameState.player.height / 2 - 13, 4, 8);
    
    ctx.fillStyle = '#87ceeb';
    ctx.fillRect(-6, -10, 12, 8);
    
    ctx.restore();
  }

  function updatePlayer() {
    if (!gameState.gameRunning) return;
    
    if (gameState.keys['ArrowUp']) {
      gameState.player.speed = Math.min(gameState.player.speed + gameState.player.acceleration, 
                                        gameState.player.maxSpeed);
    } else if (gameState.keys['ArrowDown']) {
      gameState.player.speed = Math.max(gameState.player.speed - gameState.player.acceleration * 2, 
                                        -gameState.player.maxSpeed / 2);
    } else {
      gameState.player.speed *= gameState.player.friction;
    }
    
    if (gameState.keys['ArrowLeft']) {
      gameState.player.angle -= 0.05 * (gameState.player.speed / gameState.player.maxSpeed);
      gameState.player.x -= 2;
    }
    if (gameState.keys['ArrowRight']) {
      gameState.player.angle += 0.05 * (gameState.player.speed / gameState.player.maxSpeed);
      gameState.player.x += 2;
    }
    
    gameState.camera.y += gameState.player.speed;
    gameState.score += Math.floor(gameState.player.speed);
    
    checkCollision();
  }

  function checkCollision() {
    const currentSegmentIndex = Math.floor(gameState.camera.y / 10);
    if (currentSegmentIndex >= gameState.track.segments.length) return;
    
    const segment = gameState.track.segments[currentSegmentIndex];
    const trackLeft = segment.centerX - segment.width / 2;
    const trackRight = segment.centerX + segment.width / 2;
    
    if (gameState.player.x < trackLeft + 10 || gameState.player.x > trackRight - 10) {
      gameOver();
    }
  }

  function gameOver() {
    gameState.gameRunning = false;
    document.getElementById('finalScore').textContent = gameState.score;
    document.getElementById('gameOver').style.display = 'block';
  }

  function restartGame() {
    gameState.player.x = canvas.width / 2;
    gameState.player.y = canvas.height - 100;
    gameState.player.speed = 0;
    gameState.player.angle = 0;
    gameState.camera.y = 0;
    gameState.score = 0;
    gameState.gameRunning = true;
    document.getElementById('gameOver').style.display = 'none';
    generateTrack();
  }

  function updateUI() {
    document.getElementById('score').textContent = gameState.score;
    document.getElementById('speed').textContent = Math.floor(gameState.player.speed * 40);
  }

  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawTrack();
    updatePlayer();
    drawCar();
    updateUI();
    
    requestAnimationFrame(gameLoop);
  }

  document.addEventListener('keydown', (e) => {
    gameState.keys[e.code] = true;
  });

  document.addEventListener('keyup', (e) => {
    gameState.keys[e.code] = false;
  });

  document.getElementById('restartBtn')?.addEventListener('click', restartGame);

  generateTrack();
  gameLoop();
</script>
